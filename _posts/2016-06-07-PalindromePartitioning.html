---
layout: default
title: (leetcode131)Palindrome Partitioning
---

<h2>{{ page.title }}</h2>
<p>可以根据动态规划思想，用一个二维数组dp[i][j]表示字符串s从i到j的字符是否为回文串，然后采用深度优先遍历求得结果</p>
{% highlight ruby %} 
public class Solution {
	private List<String> subList;
	private List<List<String>> list;
	private void dfs(String s,boolean[][] dp,int start)		//深度优先求结果
	{
		if(start>=s.length())
		{
			list.add(new ArrayList(subList));
			return ;
		}
		StringBuilder sb=new StringBuilder();
		for(int i=start;i<s.length();i++)
		{
			sb.append(s.charAt(i));
			if(dp[start][i])
			{
				subList.add(sb.toString());
				dfs(s,dp,i+1);
				subList.remove(subList.size()-1);
			}
		}
	}
	
    public List<List<String>> partition(String s) {
    	subList=new ArrayList<String>();
    	list=new ArrayList<List<String>>();
    	if(s==null||s.length()==0)
    		return list;
    	if(s.length()==1)
    	{
    		subList.add(s);
    		list.add(subList);
    		return list;
    	}
    	boolean[][] dp=new boolean[s.length()][s.length()];
    	for(int i=s.length()-1;i>=0;i--)					//判断dp[i][j]是否为真
    		for(int j=i;j<s.length();j++)
    		{
    			if(i==j)
    			{
    				dp[i][j]=true; 
    				continue;
    			}
    			if((j-i==1||dp[i+1][j-1])&&s.charAt(i)==s.charAt(j))
    				dp[i][j]=true;
    		}
    	
    	dfs(s,dp,0);
    	return list;    	
    }
}
 {% endhighlight %}
<p>{{ page.date | date_to_string }}</p>