---
layout: default
title: (leetcode133)Clone Graph
---

<h2>{{ page.title }}</h2>
<p>复制复杂链表的思想可以应用到此题当中，深度优先遍历图并用一个哈希表存储原图中的结点与clone图中对应的结点，最后遍历哈希表
把clone图中结点的neighbors进行填充</p>
{% highlight ruby %} 
public class Solution {
	//深度优先遍历图并用一个哈希表存储原图中的结点与clone图中对应的结点
    private void cloneGraph(UndirectedGraphNode node,Map<UndirectedGraphNode,UndirectedGraphNode> map) {
    	if(!map.containsKey(node))
    		map.put(node, new UndirectedGraphNode(node.label));
    	else return;
        for(UndirectedGraphNode tmpNode:node.neighbors)
        {
        	cloneGraph(tmpNode,map);
        }
    }

    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    	if(node==null)
    		return null;
    	Map<UndirectedGraphNode,UndirectedGraphNode> map=new HashMap<UndirectedGraphNode,UndirectedGraphNode>();
    	cloneGraph(node,map);
		//遍历哈希表把clone图中结点的neighbors进行填充
    	for(UndirectedGraphNode tmpNode:map.keySet())
    	{
			UndirectedGraphNode mapNode=map.get(tmpNode);
    		for(UndirectedGraphNode listNode:tmpNode.neighbors)
    		{
    			mapNode.neighbors.add(map.get(listNode));
    		}
    	}
    	
    	return map.get(node);
    }
}
 {% endhighlight %}
<p>{{ page.date | date_to_string }}</p>