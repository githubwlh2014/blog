---
layout: default
title: (leetcode109)Convert Sorted List to Binary Search Tree
---

<h2>{{ page.title }}</h2>
<p>此题有两种解法，首先可以把链表转为数组，然后转化为108题的解法；另外一种解法为不转化直接采用一种中序遍历的思想进行递归建树</p>
{% highlight ruby %} 
解法一：
	public TreeNode buildBalancedTree(int[] nums,int low,int high)
	{
		int mid=(low+high)>>1;
		TreeNode t=new TreeNode(nums[mid]);
		if(mid>low)
			t.left=buildBalancedTree(nums,low,mid-1);
		if(mid<high)
			t.right=buildBalancedTree(nums,mid+1,high);
		return t;
	}
	
    public TreeNode sortedListToBST(ListNode head) {
        if(head==null)
        	return null;
    	int i=0;
    	ListNode tmp=head;
        while(tmp!=null)
        {
        	i++;
        	tmp=tmp.next;
        }
        int[] nums=new int[i];
        i=0;
        tmp=head;
        while(tmp!=null)
        {
        	nums[i++]=tmp.val;
        	tmp=tmp.next;
        }
        return buildBalancedTree(nums,0,nums.length-1);
    }
解法二：
public class Solution {
	private ListNode node;

	public TreeNode sortedListToBST(ListNode head) {
		if(head == null){
			return null;
		}

		int size = 0;
		ListNode runner = head;
		node = head;

		while(runner != null){
			runner = runner.next;
			size ++;
		}

		return inorderHelper(0, size - 1);
	}

	public TreeNode inorderHelper(int start, int end){
		if(start > end){
			return null;
		}

		int mid = start + (end - start) / 2;
		TreeNode left = inorderHelper(start, mid - 1);

		TreeNode treenode = new TreeNode(node.val);
		treenode.left = left;
		node = node.next;

		TreeNode right = inorderHelper(mid + 1, end);
		treenode.right = right;

		return treenode;
	}

}
 {% endhighlight %}
<p>{{ page.date | date_to_string }}</p>